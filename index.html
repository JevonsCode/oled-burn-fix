<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>OLED 烧屏修复工具</title>
  <style>
    html,body{
      margin:0;
      padding:0;
      height:100%;
      overflow:hidden;
      background:#000;
      color:#fff;
      font-family:sans-serif;
    }
    /* 全屏绘图区域 */
    #canvas{
      display:block;
      width:100%;
      height:100%;
      background:#000;
    }
    /* 控制面板样式 */
    #controls{
      position:fixed;
      top:10px;
      left:10px;
      z-index:10;
      background:rgba(0,0,0,0.6);
      padding:12px;
      border-radius:8px;
    }
    #controls label{
      display:block;
      margin-top:6px;
      font-size:14px;
    }
    #controls button{
      margin-right:5px;
    }

    /* 下拉框样式，确保在深色背景上可见 */
    #controls select{
      background: #222;
      color: #fff;
      border: 1px solid #555;
      padding: 4px;
      border-radius: 4px;
      margin-top: 4px;
    }
    #controls option{
      color: #000;
    }
  </style>
</head>
<body>
  <!-- 用于绘制更复杂图案的画布 -->
  <canvas id="canvas"></canvas>
  <div id="controls">
    <button id="start">开始</button>
    <button id="stop" disabled>停止</button>
    <button id="fs">全屏</button>
    <label>速度: <span id="speedVal">100</span>ms
      <input type="range" id="speed" min="50" max="2000" step="50" value="100">
    </label>
    <label>模式:
      <select id="mode">
        <option value="preset">预设颜色</option>
        <option value="random">随机颜色</option>
        <option value="hue">彩虹渐变</option>
        <option value="noise">随机噪点</option>
        <option value="bars">移动条纹</option>
        <option value="circles">彩色圆</option>
      </select>
    </label>
  </div>
  <script>
    (function(){
      // 预设颜色序列，包含更多丰富的颜色
      // 预设颜色序列，包含更加丰富的颜色组合，取自色环每隔30°的色调，覆盖红、橙、黄、绿、青、蓝、紫等，另外包含黑白和几种过渡色，可模仿修复视频中的不同色彩闪烁效果
      const preset=[
        '#ff0000', // 红
        '#ff7f00', // 橙
        '#ffff00', // 黄
        '#7fff00', // 黄绿
        '#00ff00', // 绿
        '#00ff7f', // 蓝绿
        '#00ffff', // 青
        '#007fff', // 天蓝
        '#0000ff', // 蓝
        '#7f00ff', // 蓝紫
        '#ff00ff', // 紫
        '#ff007f', // 紫红
        '#ffffff', // 白
        '#000000', // 黑
        '#00ff99', // 青绿
        '#9900ff', // 深紫
        '#ff6600', // 橙红
        '#0066ff', // 亮蓝
        '#66ff00', // 亮绿
        '#ff0066'  // 桃红
      ];
      const canvas=document.getElementById('canvas');
      const ctx=canvas.getContext('2d');
      const startBtn=document.getElementById('start');
      const stopBtn=document.getElementById('stop');
      const fsBtn=document.getElementById('fs');
      const speedInput=document.getElementById('speed');
      const speedVal=document.getElementById('speedVal');
      const modeSelect=document.getElementById('mode');
      let timer=null;
      let hue=0;
      let index=0;
      let barOffset=0;
      // 调整画布大小以适配屏幕
      function resize(){
        canvas.width=window.innerWidth;
        canvas.height=window.innerHeight;
      }
      window.addEventListener('resize',resize);
      resize();
      // 根据模式返回下一个颜色
      function nextColor(){
        const mode=modeSelect.value;
        if(mode==='preset'){
          const c=preset[index % preset.length];
          index++;
          return c;
        } else if(mode==='random'){
          const r=Math.floor(Math.random()*256);
          const g=Math.floor(Math.random()*256);
          const b=Math.floor(Math.random()*256);
          return 'rgb('+r+','+g+','+b+')';
        } else if(mode==='hue'){
          hue=(hue+5)%360;
          return 'hsl('+hue+',100%,50%)';
        }
        return '#000000';
      }
      // 绘制下一帧
      function draw(){
        const mode=modeSelect.value;
        const w=canvas.width;
        const h=canvas.height;
        if(mode==='noise'){
          // 随机噪点：为每个像素生成随机颜色
          const imgData=ctx.createImageData(w,h);
          const data=imgData.data;
          for(let i=0;i<data.length;i+=4){
            data[i]=Math.random()*255;
            data[i+1]=Math.random()*255;
            data[i+2]=Math.random()*255;
            data[i+3]=255;
          }
          ctx.putImageData(imgData,0,0);
        } else if(mode==='bars'){
          // 移动条纹：用随机颜色绘制移动条纹
          const barWidth=100;
          barOffset=(barOffset+10)%barWidth;
          ctx.fillStyle='#000';
          ctx.fillRect(0,0,w,h);
          for(let x=-barWidth+barOffset;x<w;x+=barWidth){
            ctx.fillStyle=nextColor();
            ctx.fillRect(x,0,barWidth/2,h);
          }
        } else if(mode==='circles'){
          // 多彩圆：随机位置和半径的圆形，使用 nextColor() 生成颜色
          ctx.fillStyle='#000';
          ctx.fillRect(0,0,w,h);
          const count=Math.floor((w*h)/50000); // 根据画布大小调整圆的数量
          for(let i=0;i<count;i++){
            const radius=Math.random()*60+20;
            const x=Math.random()*w;
            const y=Math.random()*h;
            ctx.beginPath();
            ctx.arc(x,y,radius,0,Math.PI*2);
            ctx.fillStyle=nextColor();
            ctx.fill();
          }
        } else {
          // 单一颜色填充（默认模式）
          ctx.fillStyle=nextColor();
          ctx.fillRect(0,0,w,h);
        }
      }
      // 开始循环
      function start(){
        stop();
        index=0;
        hue=0;
        barOffset=0;
        timer=setInterval(draw,parseInt(speedInput.value));
        startBtn.disabled=true;
        stopBtn.disabled=false;
      }
      // 停止循环
      function stop(){
        if(timer){
          clearInterval(timer);
          timer=null;
        }
        startBtn.disabled=false;
        stopBtn.disabled=true;
      }
      // 绑定事件
      startBtn.addEventListener('click',start);
      stopBtn.addEventListener('click',stop);
      fsBtn.addEventListener('click',()=>{
        if(!document.fullscreenElement){
          document.documentElement.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      });
      speedInput.addEventListener('input',()=>{
        speedVal.textContent=speedInput.value;
        if(timer){
          // 重启以应用新的速度
          start();
        }
      });
      modeSelect.addEventListener('change',()=>{
        index=0;
        hue=0;
        barOffset=0;
      });
    })();
  </script>
</body>
</html>
