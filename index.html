<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>OLED 烁屏修复工具</title>
  <style>
    html,body{
      margin:0;
      padding:0;
      height:100%;
      overflow:hidden;
      background:#000;
      color:#fff;
      font-family:sans-serif;
    }
    /* 全屏绘图区域 */
    #canvas{
      display:block;
      width:100%;
      height:100%;
      background:#000;
    }
    /* 控制面板样式 */
    #controls{
      position:fixed;
      top:10px;
      left:10px;
      z-index:10;
      background:rgba(0,0,0,0.6);
      padding:12px;
      border-radius:8px;
      /* 添加淡入淡出动画，用于自动隐藏 */
      transition:opacity 0.5s ease;
    }
    #controls label{
      display:block;
      margin-top:6px;
      font-size:14px;
    }
    #controls button{
      margin-right:5px;
    }

    /* 下拉框样式，确保在深色背景上可见 */
    #controls select{
      background: #222;
      color: #fff;
      border: 1px solid #555;
      padding: 4px;
      border-radius: 4px;
      margin-top: 4px;
    }
    #controls option{
      /* 设置选项文字为白色，避免黑底黑字看不见 */
      color: #fff;
    }
  </style>
</head>
<body>
  <!-- 用于绘制更复杂图案的画布 -->
  <canvas id="canvas"></canvas>
  <div id="controls">
    <button id="start">开始</button>
    <button id="stop" disabled>停止</button>
    <button id="fs">全屏</button>
    <label>速度: <span id="speedVal">100</span>ms
      <input type="range" id="speed" min="50" max="2000" step="50" value="100">
    </label>
    <label>模式:
      <select id="mode">
        <option value="preset">预设颜色</option>
        <option value="random">随机颜色</option>
        <option value="hue">彩虹渐变</option>
        <option value="noise">随机噪点</option>
        <option value="bars">移动条纹</option>
        <option value="circles">彩色圆</option>
        <option value="randomAll">全随机</option>
      </select>
    </label>
  </div>
  <script>
    (function(){
      // 预设颜色序列，包含更多丰富的颜色
      // 预设颜色序列，包含更加丰富的颜色组合，取自色环每隔30°的色调，覆盖红、橙、黄、绿、青、蓝、紫等，另外包含黑白和几种过渡色，可模仿修复视频中的不同色彩闪烁效果
      const preset=[
        '#ff0000', // 红
        '#ff7f00', // 橙
        '#ffff00', // 黄
        '#7fff00', // 黄绿
        '#00ff00', // 绿
        '#00ff7f', // 蓝绿
        '#00ffff', // 青
        '#007fff', // 天蓝
        '#0000ff', // 蓝
        '#7f00ff', // 蓝紫
        '#ff00ff', // 紫
        '#ff007f', // 紫红
        '#ffffff', // 白
        '#000000', // 黑
        '#00ff99', // 青绿
        '#9900ff', // 深紫
        '#ff6600', // 橙红
        '#0066ff', // 亮蓝
        '#66ff00', // 亮绿
        '#ff0066'  // 桃红
      ];
      const canvas=document.getElementById('canvas');
      const ctx=canvas.getContext('2d');
      const startBtn=document.getElementById('start');
      const stopBtn=document.getElementById('stop');
      const fsBtn=document.getElementById('fs');
      const speedInput=document.getElementById('speed');
      const speedVal=document.getElementById('speedVal');
      const modeSelect=document.getElementById('mode');
      let timer=null;
      let hue=0;
      let index=0;
      let barOffset=0;
      // 调整画布大小以适配屏幕
      function resize(){
        canvas.width=window.innerWidth;
        canvas.height=window.innerHeight;
      }
      window.addEventListener('resize',resize);
      resize();
      // 根据模式返回下一颜色
      function nextColor(){
        const mode=modeSelect.value;
        if(mode==='preset'){
          // 从预设颜色序列中依次取出颜色
          const c=preset[index % preset.length];
          index++;
          return c;
        } else if(mode==='random'){
          // 随机生成一个 RGB 颜色
          const r=Math.floor(Math.random()*256);
          const g=Math.floor(Math.random()*256);
          const b=Math.floor(Math.random()*256);
          return 'rgb('+r+','+g+','+b+')';
        } else if(mode==='hue'){
          // 按色相环渐变
          hue=(hue+5)%360;
          return 'hsl('+hue+',100%,50%)';
        } else if(mode==='randomAll'){
          // 在全随机模式下，随机选择颜色生成方式
          const colorModes=['preset','random','hue'];
          const cm=colorModes[Math.floor(Math.random()*colorModes.length)];
          if(cm==='preset'){
            const c=preset[index % preset.length];
            index++;
            return c;
          } else if(cm==='random'){
            const r=Math.floor(Math.random()*256);
            const g=Math.floor(Math.random()*256);
            const b=Math.floor(Math.random()*256);
            return 'rgb('+r+','+g+','+b+')';
          } else {
            hue=(hue+5)%360;
            return 'hsl('+hue+',100%,50%)';
          }
        }
        // 默认返回黑色
        return '#000000';
      }
      // 绘制下一帧
      function draw(){
        const mode=modeSelect.value;
        const w=canvas.width;
        const h=canvas.height;
        if(mode==='noise'){
          // 随机噪点：为每个像素生成随机颜色
          const imgData=ctx.createImageData(w,h);
          const data=imgData.data;
          for(let i=0;i<data.length;i+=4){
            data[i]=Math.random()*255;
            data[i+1]=Math.random()*255;
            data[i+2]=Math.random()*255;
            data[i+3]=255;
          }
          ctx.putImageData(imgData,0,0);
        } else if(mode==='bars'){
          // 移动条纹：用随机颜色绘制移动条纹
          const barWidth=100;
          barOffset=(barOffset+10)%barWidth;
          ctx.fillStyle='#000';
          ctx.fillRect(0,0,w,h);
          for(let x=-barWidth+barOffset;x<w;x+=barWidth){
            ctx.fillStyle=nextColor();
            ctx.fillRect(x,0,barWidth/2,h);
          }
        } else if(mode==='circles'){
          // 多彩圈：随机位置和半径的圈形，使用 nextColor() 生成颜色
          ctx.fillStyle='#000';
          ctx.fillRect(0,0,w,h);
          const count=Math.floor((w*h)/50000); // 根据画布大小调整圈的数量
          for(let i=0;i<count;i++){
            const radius=Math.random()*60+20;
            const x=Math.random()*w;
            const y=Math.random()*h;
            ctx.beginPath();
            ctx.arc(x,y,radius,0,Math.PI*2);
            ctx.fillStyle=nextColor();
            ctx.fill();
          }
        } else if (mode==='randomAll'){
          // 全随机模式：每帧随机选择一种模式来绘制
          const modes=['preset','random','hue','noise','bars','circles'];
          const rnd=modes[Math.floor(Math.random()*modes.length)];
          if(rnd==='noise'){
            const imgData=ctx.createImageData(w,h);
            const data=imgData.data;
            for(let i=0;i<data.length;i+=4){
              data[i]=Math.random()*255;
              data[i+1]=Math.random()*255;
              data[i+2]=Math.random()*255;
              data[i+3]=255;
            }
            ctx.putImageData(imgData,0,0);
          } else if(rnd==='bars'){
            const barWidth=100;
            barOffset=(barOffset+10)%barWidth;
            ctx.fillStyle='#000';
            ctx.fillRect(0,0,w,h);
            for(let x=-barWidth+barOffset;x<w;x+=barWidth){
              ctx.fillStyle=nextColor();
              ctx.fillRect(x,0,barWidth/2,h);
            }
          } else if(rnd==='circles'){
            ctx.fillStyle='#000';
            ctx.fillRect(0,0,w,h);
            const count=Math.floor((w*h)/50000);
            for(let i=0;i<count;i++){
              const radius=Math.random()*60+20;
              const x=Math.random()*w;
              const y=Math.random()*h;
              ctx.beginPath();
              ctx.arc(x,y,radius,0,Math.PI*2);
              ctx.fillStyle=nextColor();
              ctx.fill();
            }
          } else {
            // preset/random/hue 模式下，直接使用 nextColor() 填充整屏
            ctx.fillStyle=nextColor();
            ctx.fillRect(0,0,w,h);
          }
        } else {
          // 单一颜色填充（默认模式）
          ctx.fillStyle=nextColor();
          ctx.fillRect(0,0,w,h);
        }
      }
      // 开始循环
      function start(){
        stop();
        index=0;
        hue=0;
        barOffset=0;
        timer=setInterval(draw,parseInt(speedInput.value));
        startBtn.disabled=true;
        stopBtn.disabled=false;
      }
      // 停止循环
      function stop(){
        if(timer){
          clearInterval(timer);
          timer=null;
        }
        startBtn.disabled=false;
        stopBtn.disabled=true;
      }
      // 线合事件
      startBtn.addEventListener('click',start);
      stopBtn.addEventListener('click',stop);
      fsBtn.addEventListener('click',()=>{
        if(!document.fullscreenElement){
          document.documentElement.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      });
      speedInput.addEventListener('input',()=>{
        speedVal.textContent=speedInput.value;
        if(timer){
          // 重启以应用新的速度
          start();
        }
      });
      modeSelect.addEventListener('change',()=>{
        index=0;
        hue=0;
        barOffset=0;
      });

      // 自动隐藏控制面板：若鼠标或触摸在3秒内没有移动，则隐藏控制栏
      const controls = document.getElementById('controls');
      let hideTimer;
      function resetHideTimer(){
        // 显示控制栏
        controls.style.opacity = '1';
        controls.style.pointerEvents = 'auto';
        if(hideTimer) clearTimeout(hideTimer);
        hideTimer = setTimeout(() => {
          controls.style.opacity = '0';
          controls.style.pointerEvents = 'none';
        }, 3000);
      }
      // 监听鼠标移动和触摸事件
      document.addEventListener('mousemove', resetHideTimer);
      document.addEventListener('touchstart', resetHideTimer);
      // 初始启动定时器
      resetHideTimer();
    })();
  </script>
</body>
</html>
